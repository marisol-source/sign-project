{% load static %}
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Reconocimiento de Gestos</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-white-900 text-white overflow-hidden">

  <!-- Navbar -->
  <nav class="fixed top-0 left-0 w-full bg-white shadow-md z-30">
    <div class="max-w-7xl mx-auto flex justify-between items-center py-3 px-6">
      <!-- Logo -->
      <img src="{% static 'img/logotipo.png' %}" alt="Logo" class="w-36 h-auto">

      <!-- Men√∫ + Botones a la derecha -->
      <div class="hidden md:flex items-center space-x-8 text-gray-700 font-medium">
        <a href="#inicio" class="hover:text-blue-600 transition">Inicio</a>
        <a href="{% url 'demo' %}" class="hover:text-blue-600 transition">Demo</a>
        <a href="{% url 'home' %}#nosotros" class="hover:text-blue-600 transition">Nosotros</a>

        {% if request.session.empresa_id %}
        <!-- Men√∫ de usuario (solo logeado) -->
        <div class="relative ml-6">
          <button id="user-menu-btn" class="flex items-center space-x-2 focus:outline-none group">
            <div id="user-avatar" class="w-9 h-9 rounded-full bg-blue-600 text-white flex items-center justify-center font-bold text-lg border border-gray-200">
            {{ request.session.empresa_nombre|first|upper }}
            </div>
            <span class="font-semibold text-gray-800 group-hover:text-blue-600 transition">
          {{ request.session.empresa_nombre }}
            </span>
            <svg class="w-4 h-4 text-gray-600 group-hover:text-blue-600 transition" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"/>
            </svg>
          </button>
          <!-- Dropdown -->
          <div id="user-menu" class="hidden absolute right-0 mt-2 w-44 bg-white rounded-lg shadow-lg border border-gray-100">
            <a href="{% url 'logout' %}" class="block px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-t-lg">Cerrar sesi√≥n</a>
          </div>
        </div>
        {% endif %}
      </div>

      <!-- Bot√≥n men√∫ m√≥vil (opcional) -->
      <button class="md:hidden text-gray-900 font-bold" id="menu-btn">‚ò∞</button>
    </div>
  </nav>

  <!-- espacio para que el contenido no quede bajo el navbar -->
  <div class="pt-20"></div>

  <!-- Video y Canvas -->
<video id="input_video" autoplay playsinline class="absolute w-[1280px] h-[720px] rounded-xl object-cover top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"></video>
<canvas id="output_canvas" class="absolute w-[1280px] h-[720px] rounded-xl object-cover top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"></canvas>

  <!-- Panel superior (temporizador/estado) -->
<div class="absolute left-5 top-40 w-80 bg-gray-800/90 p-4 rounded-xl shadow-lg overflow-y-auto z-20">

    <div class="flex justify-between items-center mb-2">
      <span>‚è±Ô∏è Estado:</span>
      <span id="estado" class="font-semibold">Detectando...</span>
    </div>
    <div class="w-full h-2 bg-gray-700 rounded-full overflow-hidden mb-2">
      <div id="barra" class="h-full bg-blue-500 transition-all duration-150" style="width:0%"></div>
    </div>
    <div class="flex justify-between items-center">
      <span>üïí Temporizador:</span>
      <span id="timerValue" class="font-semibold">0.0 s</span>
    </div>
  </div>

  <!-- Chat lateral (texto BLANCO y bajo el navbar) -->
  <div class="absolute right-5 top-36 w-80 h-96 bg-gray-800/90 p-4 rounded-xl shadow-lg overflow-y-auto z-20">
    <h3 class="text-lg font-bold mb-2">ü™û Chat de Interpretaci√≥n</h3>
    <div id="chat" class="text-sm text-white space-y-1 overflow-y-auto h-80"></div>
  </div>

  <!-- Controles -->
  <div class="absolute bottom-5 flex space-x-6 justify-center w-full z-20">
    <button id="btnCam" class="flex items-center justify-center w-20 h-20 bg-blue-600 hover:bg-blue-500 active:bg-blue-700 text-white rounded-2xl shadow-xl transition transform hover:scale-110">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="currentColor" viewBox="0 0 24 24">
        <path d="M4 5a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V7a2 2 0 00-2-2h-4.586l-1.707-1.707A1 1 0 0014.586 3H9.414a1 1 0 00-.707.293L7 5H4zM12 9a4 4 0 110 8 4 4 0 010-8z"/>
      </svg>
    </button>
    <button id="btnPause" class="flex items-center justify-center w-20 h-20 bg-yellow-500 hover:bg-yellow-400 active:bg-yellow-600 text-white rounded-2xl shadow-xl transition transform hover:scale-110">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="currentColor" viewBox="0 0 24 24">
        <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
      </svg>
    </button>
    <button id="btnReset" class="flex items-center justify-center w-20 h-20 bg-indigo-600 hover:bg-indigo-500 active:bg-indigo-700 text-white rounded-2xl shadow-xl transition transform hover:scale-110">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="currentColor" viewBox="0 0 24 24">
        <path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6h-2c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/>
      </svg>
    </button>
    <button id="btnStop" class="flex items-center justify-center w-20 h-20 bg-red-600 hover:bg-red-500 active:bg-red-700 text-white rounded-2xl shadow-xl transition transform hover:scale-110">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="currentColor" viewBox="0 0 24 24">
        <path d="M6 6h12v12H6z"/>
      </svg>
    </button>
  </div>

  <!-- scripts del navbar (dropdown) -->
  <script>
    const userBtn = document.getElementById('user-menu-btn');
    const userMenu = document.getElementById('user-menu');
    if (userBtn && userMenu) {
      userBtn.addEventListener('click', () => userMenu.classList.toggle('hidden'));
      document.addEventListener('click', (e) => {
        if (!userBtn.contains(e.target) && !userMenu.contains(e.target)) userMenu.classList.add('hidden');
      });
    }
  </script>

<script>
  // ==============================
  // INICIALIZACI√ìN DE C√ÅMARA Y MEDIA PIPE
  // ==============================
  const CONFIG = {
    RES_W: 1280,
    RES_H: 720,
    PAUSA_LETRA: 1.5,
    PAUSA_PALABRA: 3.0,
    PAUSA_ORACION: 3.5,
    PAUSA_TEMPORIZADOR: 5.0,
    CONF_THRESH: 0.85,
    BUFFER_SIZE: 5,
    MIN_CONFIDENCE: 0.5,
    COOLDOWN_LETRA_MS: 1000, 
  };

const video = document.getElementById('input_video');
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d');

let cameraInstance = null;

async function setupCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { width: CONFIG.RES_W, height: CONFIG.RES_H, facingMode: 'user' },
    audio: false
  });
  video.srcObject = stream;
  await video.play();
  return stream;
}

const hands = new Hands({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: CONFIG.CONF_THRESH,
  minTrackingConfidence: CONFIG.CONF_THRESH
});

hands.onResults(onResults);  // Esta funci√≥n la definimos aparte m√°s abajo

video.addEventListener('loadeddata', () => {
  canvas.width = CONFIG.RES_W;
  canvas.height = CONFIG.RES_H;
});

setupCamera().then(() => {
  cameraInstance = new Camera(video, {
    onFrame: async () => { await hands.send({ image: video }); },
    width: CONFIG.RES_W,
    height: CONFIG.RES_H
  });
  cameraInstance.start();
});


// ==============================
// VARIABLES DE ESTADO
// ==============================
const estado = document.getElementById('estado');
const barra = document.getElementById('barra');
const timerValue = document.getElementById('timerValue');
const chat = document.getElementById('chat');

let lastGestureTime = Date.now();
let lastDetected = false;
let currentTimer = 0;
let cameraOn = true;
let paused = false;

// --- Buffer para letras ---
let bufferLetras = [];
let ultimaLetra = null;
let cooldownLetraHasta = 0;
let textoOracion = "";

// Tiempos y control de env√≠o de oraci√≥n (como en el c√≥digo largo)
let lastLetterTime = Date.now();    // √∫ltima letra aceptada
let lastActivityTime = Date.now();  // √∫ltima actividad "real" (letra aceptada)
let oracionEnviada = false;         // para no repetir la misma oraci√≥n
let interpretationActive = true;    // por ahora siempre true


// ==============================
// FUNCIONES DE DETECCI√ìN Y PROCESAMIENTO
// ==============================
function onResults(results) {
  if (paused) return;

  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

  const now = Date.now();

  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    const landmarks = results.multiHandLandmarks[0];

    // Dibujar mano
    drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 3 });
    drawLandmarks(ctx, landmarks, { color: '#FF0000', lineWidth: 3, radius: 5 });

    // Enviar datos a API
    if (now >= cooldownLetraHasta) {
      enviarLandmarksAPI(landmarks);
      estado.textContent = '‚úã Mano detectada';
    } else {
      estado.textContent = '‚è∏Ô∏è Esperando siguiente letra...';
    }

    lastGestureTime = now;
    lastDetected = true;
    currentTimer = 0;
  } else {
    manejarTemporizador(now);
  }

  ctx.restore();
}



// ==============================
// FUNCION AUXILIAR PARA ENVIAR LANDMARKS A API
// ==============================
// Variables de control de aceptaci√≥n real
let lastAcceptedLetter = null;
let lastAcceptedTime = 0; // ms

function enviarLandmarksAPI(landmarks) {
  // Convertimos los landmarks a un formato simple compatible con tu API
  const payload = {
    landmarks: landmarks.map(p => ({ x: 1 - p.x, y: p.y, z: p.z }))
  };

  fetch("http://127.0.0.1:8001/api/test/", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  })
    .then(res => res.json())
    .then(data => {
      if (data.letter && data.confidence >= CONFIG.MIN_CONFIDENCE) {
        // Actualizar buffer y detectar la letra m√°s frecuente
        bufferLetras.push(data.letter);
        if (bufferLetras.length > CONFIG.BUFFER_SIZE) bufferLetras.shift();

        const counts = {};
        bufferLetras.forEach(l => counts[l] = (counts[l] || 0) + 1);
        const mostFrequent = Object.keys(counts).reduce((a,b) => counts[a] > counts[b] ? a : b);
        const frecuencia = counts[mostFrequent] / CONFIG.BUFFER_SIZE;
        const ahora = Date.now();

        // Condici√≥n para aceptar la letra:
        // - aceptar si la frecuencia es suficiente (>= 75%)
        // - y adem√°s (la letra es distinta a la √∫ltima aceptada) o (es la misma pero ya pas√≥ la pausa)
        const tiempoDesdeUltimaAceptada = ahora - lastAcceptedTime;
        const pausaLetraMs = CONFIG.PAUSA_LETRA * 1000;

        if (frecuencia >= 0.75) {
          const esMisma = (mostFrequent === lastAcceptedLetter);
          const puedeRepetir = esMisma && (tiempoDesdeUltimaAceptada >= pausaLetraMs);
          const esNueva = !esMisma;

          if (esNueva || puedeRepetir) {
            // Aceptamos la letra
            lastAcceptedLetter = mostFrequent;
            lastAcceptedTime = ahora;

            // Actualizamos la oraci√≥n y tiempos
            textoOracion += mostFrequent;
            console.log("‚û°Ô∏è textoOracion tras letra:", textoOracion);

            lastLetterTime = ahora;
            lastActivityTime = ahora;
            oracionEnviada = false;

            // Cooldown para evitar llamadas API demasiado seguidas
            cooldownLetraHasta = ahora + CONFIG.COOLDOWN_LETRA_MS;

            // Limpiar buffer para evitar repeticiones inmediatas por ruido
            bufferLetras = [];

            // Mostrar en el chat
            chat.innerHTML += `<div>üî§ Letra confirmada: ${mostFrequent} (Conf: ${Math.round(
              data.confidence * 100
            )}%)</div>`;
            chat.scrollTop = chat.scrollHeight;
          } else {
            // No se acepta (es la misma letra y a√∫n no pas√≥ la pausa)
            // Puedes descomentar la l√≠nea siguiente para debug
            // console.log("‚ùå Rechazada por ser repetici√≥n r√°pida:", mostFrequent);
          }
        }
      }

      if (data.error) console.error("Error API:", data.error);
    })
    .catch(err => console.error("Error fetch:", err));
}




// ==============================
// ENVIAR ORACI√ìN A GEMINI (FastAPI /api/correct/)
// ==============================
function enviarOracionAGemini(oracion) {
  if (!oracion || !oracion.trim()) return Promise.resolve(null);

  return fetch("http://127.0.0.1:8001/api/correct/", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ sentence: oracion })
  })
    .then(res => res.json())
    .then(data => {
      if (data.corrected) {
        // Mostrar oraci√≥n corregida en el chat
        chat.scrollTop = chat.scrollHeight;
        return data.corrected; // ‚úÖ devolvemos la correcci√≥n real
      } else if (data.error) {
        console.error("Error API correcci√≥n:", data.error);
        return null;
      } else {
        console.warn("Respuesta rara de /api/correct/:", data);
        return null;
      }
    })
    .catch(err => {
      console.error("Error fetch /api/correct/:", err);
      return null;
    });
}

        

// ==============================
// FUNCION AUXILIAR PARA MANEJAR TEMPORIZADOR Y ESTADO
// ==============================
function manejarTemporizador(now) {
  if (!lastDetected) return; // a√∫n no hemos visto mano/letra en esta sesi√≥n

  // Tiempos en segundos desde la √∫ltima letra y desde la √∫ltima actividad real
  const timeSinceLastLetter = (now - lastLetterTime) / 1000.0;
  const timeSinceLastActivity = (now - lastActivityTime) / 1000.0;

  // Usamos el tiempo desde la √∫ltima actividad para el temporizador principal
  currentTimer = timeSinceLastActivity;
  timerValue.textContent = currentTimer.toFixed(1);

  // 1) Detectar fin de oraci√≥n y enviarla al chat
  if (
    interpretationActive &&
    !oracionEnviada &&                 // evitar duplicados
    textoOracion.trim().length > 0 &&  // solo si hay letras acumuladas
    timeSinceLastActivity >= CONFIG.PAUSA_TEMPORIZADOR
  ) {
    estado.textContent = '‚úÖ Enviando oraci√≥n';

    const oracion = textoOracion.trim();
    chat.innerHTML += `<div>üìù Oraci√≥n: ${oracion}</div>`;
    chat.scrollTop = chat.scrollHeight;

    // üîπ MANDAR LA ORACI√ìN A GEMINI Y GUARDARLA CUANDO DEVUELVA LA CORRECCI√ìN
    enviarOracionAGemini(oracion).then(corregida => {
      if (corregida) {
        // ‚úÖ Guardamos la oraci√≥n original y su versi√≥n corregida en la BD
        guardarOracion(oracion, corregida);
        chat.innerHTML += `<div>‚úèÔ∏è Oraci√≥n corregida: ${corregida}</div>`;
      } else {
        console.warn("‚ö†Ô∏è No se pudo obtener la correcci√≥n para guardar.");
      }
    });

    console.log("üöÄ Oraci√≥n enviada:", oracion);

    // Marcar que ya se envi√≥
    oracionEnviada = true;

    // Limpiar para empezar una nueva oraci√≥n
    textoOracion = "";
    bufferLetras = [];
    ultimaLetraMostrada = null;
    tiempoUltimaLetra = 0;
    cooldownLetraHasta = 0;

    // Reiniciar contadores de tiempo
    lastActivityTime = now;
    lastLetterTime = now;
    lastDetected = false;

    return; // ya manejamos este caso
  }

  // 2) Actualizar mensaje de estado seg√∫n los tiempos
  if (timeSinceLastActivity >= CONFIG.PAUSA_TEMPORIZADOR) {
    estado.textContent = 'üó£Ô∏è Fin de oraci√≥n';
  } else if (timeSinceLastLetter >= CONFIG.PAUSA_PALABRA && textoOracion.length > 0) {
    estado.textContent = 'üí¨ Fin de palabra';
  } else if (timeSinceLastLetter >= CONFIG.PAUSA_LETRA && textoOracion.length > 0) {
    estado.textContent = 'üî§ Fin de letra';
  } else {
    estado.textContent = '‚è±Ô∏è Esperando siguiente gesto...';
  }


  // 3) Progreso barra
  const progreso = Math.min(
    (timeSinceLastActivity / CONFIG.PAUSA_TEMPORIZADOR) * 100,
    100
  );
  barra.style.width = `${progreso}%`;
}



//M√âTODO PARA GUARDAR MIS ORACIONES (ORIGINAL Y CORREGIDA) EN EL BACKEND
function guardarOracion(oracionOriginal, oracionCorregida) {
  fetch('/oraciones/guardar_oracion/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': '{{ csrf_token }}',  // Incluye el token CSRF si usas plantillas de Django
    },
    body: JSON.stringify({
      oracion_original: oracionOriginal,
      oracion_corregida: oracionCorregida,
    })
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      console.log('Oraci√≥n guardada exitosamente');
    } else {
      console.error('Error al guardar la oraci√≥n');
    }
  })
  .catch(error => console.error('Error:', error));
}


// ==============================
// EVENTOS DE BOTONES
// ==============================

// Encender/Apagar c√°mara
document.getElementById('btnCam').addEventListener('click', async () => {
  if (cameraOn) {
    const tracks = video.srcObject.getTracks();
    tracks.forEach(t => t.stop());
    estado.textContent = 'üì∑ C√°mara apagada';
    cameraOn = false;
  } else {
    await setupCamera();
    estado.textContent = 'üì∏ C√°mara encendida';
    cameraOn = true;
  }
});

// Pausar/Reanudar detecci√≥n
// Pausar/Reanudar detecci√≥n con cambio de icono
const btnPause = document.getElementById('btnPause');
btnPause.addEventListener('click', () => {
  paused = !paused;
  if (paused) {
    estado.textContent = '‚è∏Ô∏è Pausado';
    btnPause.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="currentColor" viewBox="0 0 24 24">
        <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
      </svg>
    `; // Icono de pausa
  } else {
    estado.textContent = '‚ñ∂Ô∏è Reanudado';
    btnPause.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="currentColor" viewBox="0 0 24 24">
        <path d="M8 5v14l11-7z"/>
      </svg>
    `; // Icono de play
  }
});


// Reiniciar temporizador y chat
  document.getElementById('btnReset').addEventListener('click', () => {
    lastDetected = false;
    currentTimer = 0;
    barra.style.width = '0%';
    estado.textContent = 'üîÑ Reiniciado';
    timerValue.textContent = '0.0';

    bufferLetras = [];
    ultimaLetra = null;
    ultimaLetraMostrada = null;
    tiempoUltimaLetra = 0;
    textoOracion = "";
    cooldownLetraHasta = 0;
    lastLetterTime = Date.now();
    lastActivityTime = Date.now();
    oracionEnviada = false;

    chat.innerHTML = '';
  });

// Detener √∫nicamente la detecci√≥n
document.getElementById('btnStop').addEventListener('click', () => {
  paused = true; // Solo pausa la detecci√≥n
  estado.textContent = 'üõë Reconocimiento detenido';
});



// ==============================
// INICIAR C√ÅMARA AUTOM√ÅTICAMENTE AL CARGAR
// ==============================
async function iniciarCamara() {
  await setupCamera(); // Prepara el video
  cameraInstance = new Camera(video, {
    onFrame: async () => { await hands.send({ image: video }); },
    width: CONFIG.RES_W,
    height: CONFIG.RES_H
  });
  cameraInstance.start();
  cameraOn = true;
  estado.textContent = 'üì∏ C√°mara encendida';
}

// Llamamos al cargar la p√°gina
iniciarCamara();





</script>




</body>
</html>
